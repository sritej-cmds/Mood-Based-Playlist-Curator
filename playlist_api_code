
from flask import Flask, jsonify, request
from flask_cors import CORS
from transformers import pipeline
from sentence_transformers import SentenceTransformer, util
from datetime import datetime
import requests, os, random, re, csv
import numpy as np
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from flask import render_template

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§© RAG (for smart query enhancement using songdesc.csv)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import pandas as pd
from sentence_transformers import SentenceTransformer, util
import numpy as np
import os

semantic_model = SentenceTransformer("all-MiniLM-L6-v2")

descriptions = []
desc_embeddings = None

try:
    # âœ… Use absolute or relative path
    file_path = os.path.join(os.path.dirname(__file__), "songdesc.csv")

    if not os.path.exists(file_path):
        print(f"âš  songdesc.csv not found at: {file_path}")
    else:
        df = pd.read_csv(file_path, encoding="utf-8-sig")
        if "description" not in df.columns:
            raise ValueError("CSV must contain a 'description' column")

        descriptions = df["description"].dropna().tolist()
        desc_embeddings = semantic_model.encode(descriptions, normalize_embeddings=True)
        print(f"âœ… Loaded {len(descriptions)} descriptions for RAG")

except Exception as e:
    print("âš  RAG initialization failed:", e)
    descriptions, desc_embeddings = [], None


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§  RAG QUERY ENHANCEMENT FUNCTION
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def enhance_query_with_rag(query):
    """
    Takes the user query and finds the most semantically similar
    description from songdesc.csv, returning an enhanced search string.
    """
    if not descriptions or desc_embeddings is None:
        print("âš  RAG data not loaded â€” using raw query.")
        return query

    try:
        query_emb = semantic_model.encode([query], normalize_embeddings=True)
        scores = util.cos_sim(query_emb, desc_embeddings)[0].cpu().numpy()
        best_idx = int(np.argmax(scores))
        best_description = descriptions[best_idx]

        enhanced_query = f"{query}. It feels like {best_description}"
        print(f"ğŸ” RAG-enhanced query â†’ {enhanced_query}")
        return enhanced_query

    except Exception as e:
        print("âš  RAG query enhancement error:", e)
        return query
    
def clean_for_spotify(text):
    """
    Keep only 3â€“5 strong emotion or vibe words for Spotify search.
    """
    import re
    text = text.lower()
    # remove fluff like "it feels like", punctuation, etc.
    text = re.sub(r"it feels like|feels like|songs|music|playlist|soundtrack", "", text)
    words = [w for w in re.findall(r"[a-z]+", text) if len(w) > 2]
    # keep only the top few meaningful words
    keywords = words[:5]
    return " ".join(keywords)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§  INIT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = Flask(__name__)
CORS(app)

reflect_model = pipeline("text2text-generation", model="google/flan-t5-small")
emotion_classifier = pipeline("zero-shot-classification", model="valhalla/distilbart-mnli-12-1")
sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials())

print("âœ… Models loaded: MiniLM + Flan-T5 + DistilBART + Spotipy")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# â˜ CONTEXT HELPERS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_time_of_day():
    hour = datetime.now().hour
    if 5 <= hour < 12: return "morning"
    elif 12 <= hour < 17: return "afternoon"
    elif 17 <= hour < 21: return "evening"
    else: return "night"

def get_weather_description():
    try:
        api_key = "fbd21f5d05cfd4052bdb1bb4f6c7dadf"
        city = "Bengaluru"
        data = requests.get(
            f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric",
            timeout=5,
        ).json()
        return data["weather"][0]["main"].lower()
    except Exception:
        return "unknown"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ’¬ MOOD DETECTOR
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def detect_multiple_moods(text):
    labels = ["happy","sad","angry","relaxed","romantic",
              "energetic","nervous","hopeful","lonely","neutral"]
    result = emotion_classifier(text, labels)
    moods = result["labels"][:3]
    return moods

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§ INTENT DECISION
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def decide_intent(moods, weather, tod):
    if "sad" in moods and weather in ["rain","mist","clouds"]:
        return "comfort"
    if "happy" in moods and weather == "clear":
        return "bright upbeat"
    if "romantic" in moods and tod == "night":
        return "soft love"
    if "energetic" in moods:
        return "party"
    if "relaxed" in moods:
        return "chill"
    if "angry" in moods:
        return "power"
    return "general"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸµ SPOTIFY FETCHER (uses RAG + smart vibe keywords + artist search)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_playlist(search, max_results=20):
    """
    Playlist generation simplified:
    Uses detected moods directly (no vibe keywords or RAG text).
    Fetches clean, emotion-consistent tracks.
    """
    try:
        # Step â¿¡ â€” Detect moods
        moods = detect_multiple_moods(search)
        print(f"ğŸ’­ Detected moods â†’ {moods}")

        # Manually force sadness when needed
        lower_query = search.lower()
        sad_triggers = ["broke up", "heartbroken", "lost her", "lost him", "miss", "alone", "cry", "hurt"]
        if any(w in lower_query for w in sad_triggers) and "sad" not in moods:
            moods.insert(0, "sad")
            print("ğŸ’§ Sadness trigger detected â€” added 'sad'")

        # Step â¿¢ â€” Combine moods into clean keywords
        search_terms = ", ".join(moods[:4])  # limit to 4 mood words
        print(f"ğŸ¨ Using moods for Spotify search â†’ {search_terms}")

        # Step â¿£ â€” Pick 10 major artists
        top_artists = [
            # English / Global Pop
            "Taylor Swift", "Ed Sheeran", "Adele", "Billie Eilish", "The Weeknd", "Lana Del Rey",
            "Bruno Mars", "Harry Styles", "Dua Lipa", "Selena Gomez", "SZA", "Olivia Rodrigo",
            "Sam Smith", "Coldplay", "Khalid", "Halsey", "Post Malone", "Charlie Puth", "Doja Cat",
            "Shawn Mendes", "Justin Bieber", "Imagine Dragons", "OneRepublic", "Lauv", "Maroon 5",
            # Hip-hop
            "Drake", "Kanye West", "Eminem", "Travis Scott", "Kendrick Lamar", "NF", "Juice WRLD",
            "Lil Nas X", "The Kid LAROI", "J. Cole", "21 Savage",
            # Hindi / Indian
            "Arijit Singh", "Shreya Ghoshal", "Armaan Malik", "Anuv Jain", "Prateek Kuhad", "Pritam",
            "Atif Aslam", "A. R. Rahman", "Darshan Raval", "Jubin Nautiyal", "KK", "Mohit Chauhan",
            "Sonu Nigam", "Shankar Mahadevan"
        ]
        random.shuffle(top_artists)
        selected_artists = top_artists[:10]

        # Step â¿¤ â€” Spotify searches using moods + artists
        all_tracks, seen_names = [], set()
        for artist in selected_artists:
            query = f"{search_terms}, {artist}"
            results = sp.search(q=query, type="track", limit=5)
            tracks = results.get("tracks", {}).get("items", [])

            banned = ["mashup", "remix", "edit", "mix", "cover", "bootleg", "live"]
            for t in tracks:
                name = t["name"].strip().lower()
                if name in seen_names:
                    continue
                if any(b in name for b in banned):
                    continue
                if t["artists"][0]["name"].lower() == "various artists":
                    continue

                seen_names.add(name)
                all_tracks.append(t)

        # Step â¿¥ â€” Sort & build playlist
        popular_tracks = sorted(all_tracks, key=lambda t: t.get("popularity", 0), reverse=True)
        avg_pop = np.mean([t.get("popularity", 0) for t in popular_tracks]) if popular_tracks else 0
        print(f"âœ… Playlist built with {len(popular_tracks)} tracks (avg popularity â‰ˆ {round(avg_pop, 1)})")

        fallback_previews = [
            "https://p.scdn.co/mp3-preview/4b0d7b4e1e8d7f4d1a8b6e4c11d2f2f6e9a4ef8b?cid=null",
            "https://p.scdn.co/mp3-preview/77a87bb1e8a5434db82f8c63776a9d2a5c1e8f49?cid=null",
            "https://p.scdn.co/mp3-preview/aad34e4cc69f4918bba3811b3e5e4cf90560f4b1?cid=null"
        ]

        playlist = []
        for t in popular_tracks[:max_results]:
            preview = t.get("preview_url") or random.choice(fallback_previews)
            playlist.append({
                "song": t["name"],
                "artist": t["artists"][0]["name"],
                "url": t["external_urls"]["spotify"],
                "preview": preview,
                "popularity": t.get("popularity", 0)
            })

        return playlist

    except Exception as e:
        print("âš  Spotify fetch error:", e)
        return []
def get_similar_song(song_name):
    """Find a similar song using Spotify recommendations."""
    try:
        search_results = sp.search(q=song_name, type='track', limit=1)
        tracks = search_results.get('tracks', {}).get('items', [])
        if not tracks:
            return None

        track_id = tracks[0]['id']
        recs = sp.recommendations(seed_tracks=[track_id], limit=1)
        if not recs['tracks']:
            return None

        rec_song = recs['tracks'][0]
        return {
            "name": rec_song["name"],
            "artist": rec_song["artists"][0]["name"],
            "spotify_url": rec_song["external_urls"]["spotify"]
        }
    except Exception as e:
        print("âš ï¸ Spotify recommendation error:", e)
        return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ¯ EMOTION FILTER (semantic)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def filter_emotionally_relevant_songs(songs, moods):
    if not songs or not moods:
        return songs
    mood_text = " ".join(moods)
    mood_emb = semantic_model.encode([mood_text], convert_to_tensor=True)
    scored = []
    for s in songs:
        text = f"{s['song']} {s['artist']}"
        emb = semantic_model.encode([text], convert_to_tensor=True)
        score = float(util.cos_sim(mood_emb, emb)[0])
        scored.append((s, score))
    scored.sort(key=lambda x: x[1], reverse=True)
    return [s[0] for s in scored[:10]]

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ’­ REFLECTION (unchanged)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def reflect_on_decision(moods, intent, weather, tod):
    def natural_mood_phrase(moods):
        if not moods:
            return "neutral"
        if len(moods) == 1:
            return moods[0]
        if len(moods) == 2:
            return f"{moods[0]} and {moods[1]}"
        if "energetic" in moods and "sad" in moods:
            return "a mix of sadness and restlessness"
        if "lonely" in moods and "hopeful" in moods:
            return "lonely but quietly hopeful"
        return f"{moods[0]}, {moods[1]}, and a hint of {moods[2]}"

    mood_text = natural_mood_phrase(moods)
    primary = moods[0] if moods else "neutral"

    tone_map = {
        "sad": "gentle and comforting",
        "happy": "bright and lively",
        "romantic": "soft and warm",
        "angry": "grounded and understanding",
        "relaxed": "calm and peaceful",
        "energetic": "bold and spirited",
        "lonely": "quiet and human",
        "nervous": "patient and kind",
        "hopeful": "encouraging and open",
    }
    tone = tone_map.get(primary, "empathetic")

    # --- concise, natural instruction ---
    prompt = (
        f"The listener feels {mood_text}. It's a {weather} {tod}. "
        f"I made a '{intent}' playlist for them. "
        f"Write 3â€“5 warm, first-person sentences in a {tone} tone. "
        f"Sound natural and human, like a personal reflection."
    )

    try:
        result = reflect_model(prompt, max_new_tokens=80, temperature=0.9, top_p=0.9)
        reflection = result[0]["generated_text"].strip()

        # ğŸ§¹ clean up common unwanted patterns
        reflection = re.sub(r"(?i)(^the listener.*|write 3.*|you are.*|as an ai.*)", "", reflection).strip()
        reflection = reflection.replace("them", "you").replace("listener", "you")
        reflection = re.sub(r"\s+", " ", reflection)

        # --- fallback examples if output too short or prompt-echo ---
        if len(reflection.split()) < 15 or reflection.lower().startswith("the listener"):
            examples = [
                f"I can feel the {mood_text} in your words. I made this {intent} playlist for you â€” gentle where it needs to be and steady where it should hold you. Sometimes, the right song just says what we canâ€™t.",
                f"I sensed that {mood_text} in you tonight. I built this {intent} playlist to keep you company â€” not to fix the feeling, but to make space for it.",
                f"I made this {intent} playlist for you because I know how {mood_text} moments feel. Let these songs sit beside you quietly and turn the air a little softer.",
            ]
            reflection = random.choice(examples)

        # ğŸŒ¤ small hopeful addition for positive moods
        if any(p in moods for p in {"hopeful", "romantic", "energetic", "happy"}):
            reflection += " " + random.choice([
                "And maybe one of these songs will remind you that light always finds its way back.",
                "Even in this feeling, thereâ€™s still movement â€” a rhythm waiting to rise again.",
                "I hope these tracks make the world feel a little warmer today.",
            ])

        return reflection.strip()

    except Exception as e:
        print("âš  Reflection error:", e)
        return f"I sensed your {mood_text} mood, so I made this {intent} playlist for you."

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸš€ ENDPOINTS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
playlists = []

@app.route("/playlist/context", methods=["POST"])
def playlist_with_context():
    data = request.get_json()
    query = data.get("query", "")
    moods = detect_multiple_moods(query)
    dominant = moods[0] if moods else "neutral"

    tod = get_time_of_day()
    weather = get_weather_description()
    intent = decide_intent(moods, weather, tod)

    # âœ… RAG-enhanced search + normal pipeline
    raw = get_playlist(f"{intent} {dominant} songs")
    filtered = filter_emotionally_relevant_songs(raw, moods)
    reflection = reflect_on_decision(moods, intent, weather, tod)

    songs = [
        {"song_pos": i + 1, "song_name": s["song"], "artist": s["artist"], "url": s["url"]}
        for i, s in enumerate(filtered)
    ]

    playlist = {
        "id": random.randint(1000, 9999),
        "query": query,
        "moods": moods,
        "dominant_mood": dominant,
        "intent": intent,
        "time_of_day": tod,
        "weather": weather,
        "context_note": f"{tod.capitalize()} mood detected â€” matching songs ahead.",
        "reflection": reflection,
        "songs": songs,
    }
    playlists.append(playlist)
    return jsonify(playlist)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# âœ PUT â€” Add or Update a Song in a Playlist
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.route("/playlist/<int:pid>", methods=["PUT"])
def add_or_update_song(pid):
    data = request.get_json()
    put_song = data.get('song_name', '').strip()
    artist = data.get('artist', '').strip() or "Unknown"
    mood = data.get('mood', 'unknown').strip()

    if not put_song:
        return jsonify({'message': 'song_name is required'}), 400

    for p in playlists:
        if p["id"] == pid:
            playlist_songs = p["songs"]

            # Update if exists
            for s in playlist_songs:
                if s["song_name"].lower() == put_song.lower():
                    s["mood"] = mood
                    return jsonify({'message': 'Song updated successfully', 'playlist': p}), 200

            # Add new song
            new_song = {
                'song_pos': len(playlist_songs) + 1,
                'song_name': put_song,
                'artist': artist,
                'mood': mood,
                'url': data.get('url', '')
            }
            playlist_songs.append(new_song)
            return jsonify({'message': 'Song added successfully', 'playlist': p}), 201

    return jsonify({'message': f'Playlist {pid} not found.'}), 404


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ—‘ DELETE â€” Remove a Song + Suggest Similar
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.route("/playlist/<int:pid>/<string:del_song>", methods=["DELETE"])
def delete_song(pid, del_song):
    del_song_clean = del_song.strip().lower()

    for p in playlists:
        if p["id"] == pid:
            playlist_songs = p["songs"]

            for s in playlist_songs:
                if s["song_name"].strip().lower() == del_song_clean:
                    playlist_songs.remove(s)

                    # Recalculate positions
                    for idx, song in enumerate(playlist_songs, start=1):
                        song["song_pos"] = idx

                    suggestion = get_similar_song(del_song)
                    return jsonify({
                        'message': f"'{s['song_name']}' deleted from playlist {pid}.",
                        'playlist': p,
                        'suggested_song': suggestion or "No similar song found."
                    }), 200

            return jsonify({'message': f"'{del_song}' not found in playlist {pid}."}), 404

    return jsonify({'message': f'Playlist {pid} not found.'}), 404


@app.route("/playlist", methods=["GET"])
def get_all_playlists():
    return jsonify(playlists)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    print("ğŸ¶ Running Playlist AI v17 â€” RAG Query + Full Reflection")
    app.run(debug=True, use_reloader=False,port=5001)
